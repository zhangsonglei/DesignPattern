解释器(Interpreter) 行为型：

意图：
	给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

适用性：
	当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。
	而当存在以下情况时该模式效果最好：
		1.该文法简单对于复杂的文法，文法的类层次变得庞大而无法管理。
			此时语法分析程序生成器这样的工具是更好的选择。
			它们无需构建抽象语法树即可解释表达式，这样可以节省空间而且还可能节省时间。
		2.效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的，
			而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。
			但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。

解释器模式的结构：
	1.抽象解释器(AbstractExpression)：声明一个所有具体表达式都要实现的抽象接口（或者抽象类），
		接口中主要是一个interpret()方法，称为解释操作。
		具体解释任务由它的各个实现类来完成，
		具体的解释器分别由终结符解释器TerminalExpression和
		非终结符解释器NonterminalExpression完成。
	2.终结符表达式(TerminalExpression)：实现与文法中的元素相关联的解释操作，
		通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。
		终结符一半是文法中的运算单元，
		比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。                                
	3.非终结符表达式(NonterminalExpression)：文法中的每条规则对应于一个非终结符表达式，
		非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，+就是非终结符，
		解析+的解释器就是一个非终结符表达式。
		非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。
	4.环境角色(Context)：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，
		我们给R1赋值100，给R2赋值200。
		这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。

优点：
	1.可扩展性比较好，灵活。 
	2.增加了新的解释表达式的方式。 
	3.易于实现简单文法。
	
缺点：
	1.可利用场景比较少。 
	2.对于复杂的文法比较难维护。 
	3.解释器模式会引起类膨胀。 
	4.解释器模式采用递归调用方法。
	
注意事项:
   	 解释器模式真的是一个比较少用的模式，因为对它的维护实在是太麻烦了。
   	 想象一下，一坨一坨的非终结符解释器，假如不是事先对文法的规则了如指掌，
   	 或者是文法特别简单，则很难读懂它的逻辑。
   	 解释器模式在实际的系统开发中使用的很少，因为他会引起效率、性能以及维护等问题。
   	 
实例：
	四则运算