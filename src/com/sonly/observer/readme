观察者 (Observer) 行为型:

意图：
	定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，
	所有依赖于它的对象都得到通知并被自动更新。

适用性：
	1.当一个抽象模型有两个方面，其中一个方面依赖于另一方面。
		将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。
	2.当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象有待改变。
	3.当一个对象必须通知其它对象，而它又不能假定其它对象是谁。
		换言之，你不希望这些对象是紧密耦合的。

角色：
	1.抽象被观察者：把所有对观察者对象的引用保存在一个集合中，每个被观察者角色都可以有任意数量的观察者。
		被观察者提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。
	2.抽象观察者：为所有具体的观察者定义一个接口，在得到主题的通知时更新自己。
	3.具体被观察者：在被观察者内部状态改变时，给所有登记过的观察者发出通知。
		具体被观察者角色通常用一个子类实现。
	4.具体观察者：该角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。
		通常用一个子类实现。如果需要，具体观察者角色可以保存一个指向具体主题角色的引用。

通知方式:
	拉模型: 
		Subject把自身(this)通过update()方法传递给观察者，观察者只要知道有通知到来即可。
		至于什么时候获取什么内容都可自主决定。
	推模型： 
		Subject主动向观察者推送有关状态的详细信息，推送的信息通常是目标对象的全部或部分数据。
		观察者只能被动接收。
	对比： 
		1.推模型中假定Subject知道观察者需要数据的详细信息。
		而拉模型中Subject不需要知道观察者具体需要什么数据(因此把自身传过去, 由观察者取值。
		因此，推模型会使观察者对象难以复用;
		2.拉模型下，由于update()方法参数是Subject本身，基本上可以适应各种情况的需要。

优点：
	1.观察者与被观察者之间是属于轻度的关联关系，并且是抽象耦合的，这样，对于两者来说都比较容易进行扩展。
	2.观察者模式是一种常用的触发机制，它形成一条触发链，依次对各个观察者的方法进行处理。
	但同时，这也算是观察者模式一个缺点，由于是链式触发，当观察者比较多的时候，性能问题是比较令人担忧的。
	并且，在链式结构中，比较容易出现循环引用的错误，造成系统假死。

实例：
	电商系统下单: 
	用户购买某件商品下一个订单，需要: 
	1.通知库存系统减少库存
	2.通知商家系统发货
	3.通知支付系统收钱
	4.甚至还会通知关系中心使当前用户关注该商家