模版方法(Template Method) 行为型：

意图：
	定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。
	TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

适用性：
	1.一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
	2.各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。
		这是Opdyke 和Johnson 所描述过的“重分解以一般化”的一个很好的例子[OJ93]。
		首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。
		最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。
	3.控制子类扩展。模板方法只在特定点调用“hook ”操作，这样就只允许在这些点进行扩展。
	
模式中的角色：
	1.抽象类（AbstractClass）：实现了模板方法，定义了算法的骨架。抽象类中的方法包括：
		a.抽象方法：父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。
		b.模版方法：由抽象类声明并加以实现。一般来说，模版方法调用抽象方法来完成主要的逻辑功能，
			并且，模版方法大多会定义为final类型，指明主要的逻辑功能在子类中不能被重写。
		c.钩子方法：由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。
		抽象类的任务是搭建逻辑的框架，通常由经验丰富的人员编写，因为抽象类的好坏直接决定了程序是否稳定性。
	2.具体类（ConcreteClass)：实现抽象类中的抽象方法，已完成完整的算法。
	
优点：
	模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。
	子类实现算法的某些细节，有助于算法的扩展。
	通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。

缺点：
	每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。
	
相关模式：
	Factory Method常被模板方法调用。
	Strategy: 模板方法使用继承来改变算法的一部分，Strategy使用委托来改变整个算法。
	
实例：
	不同业务的用户使用ATM机