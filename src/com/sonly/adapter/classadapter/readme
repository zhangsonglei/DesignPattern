适配器模式（Adapter） 结构型模式：

意图：
	将一个类的接口转换成客户希望的另外一个接口。
	Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 
适用性：
	你想使用一个已经存在的类，而它的接口不符合你的需求。
	你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作。
	你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。 
 	
适配器模式中的角色:
	目标接口(Target): 客户端所期待的接口；
	需要适配的类(Adaptee): 原先就存在的需要适配的类；
	适配器(Adapter): 通过包装一个需要适配的对象，把原接口转换成目标接口。

实现方式：
	类的适配器模式（采用继承实现）
	对象适配器（采用对象组合方式实现）
	
类适配器和对象适配器的权衡：
	类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。
	对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，
		因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理  Adaptee的子类了。
	对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。
		因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。
	对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。
	 对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。
	 	虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。
	对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。
	对于对象适配器，需要额外的引用来间接得到Adaptee。
	建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。
 
使用场景: 
	两个类(Target与Adaptee)所做的事情相同或相似，但是具有不同的接口；
	使用适配器之后可以使得客户端可以统一调用一个接口(Target)就行了，这样应该就可以更简单， 更直接， 更紧凑。
	系统需要使用现有的类，而这些类的接口不符合系统的接口。
	想要建立一个可以重用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。
	两个类所做的事情相同或相似，但是具有不同接口的时候。
	旧的系统开发的类已经实现了一些功能，但是客户端却只能以另外接口的形式访问，但我们不希望手动更改原有类的时候。
	使用第三方组件，组件接口定义和自己定义的不同，不希望修改自己的接口，但是要使用第三方组件

优点：

　　　通过适配器，客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单、更直接、更紧凑。
	复用了现存的类，解决了现存类和复用环境要求不一致的问题。
	将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。
	一个对象适配器可以把多个不同的适配者类适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。

缺点： 
	过多的使用适配器，会让系统非常零乱，一个系统如果太多出现这种情况，无异于一场灾难；
	因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构；
	除非是在双方都不太容易修改的时候才使用适配器模式。