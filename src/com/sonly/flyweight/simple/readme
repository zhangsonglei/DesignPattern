享元模式(Flyweight) 结构型：
	运用共享技术有效地支持大量细粒度的对象。

享元模式的结构：
	1.享元模式采用一个共享来避免大量拥有相同内容对象的开销。这种开销最常见、最直观的就是内存的损耗。
		享元对象能做到共享的关键是区分内蕴状态(Internal State)和外蕴状态(External State)。
　　	2.一个内蕴状态是存储在享元对象内部的，并且是不会随环境的改变而有所不同。
		因此，一个享元可以具有内蕴状态并可以共享。
　　	3.一个外蕴状态是随环境的改变而改变的、不可以共享的。享元对象的外蕴状态必须由客户端保存，
		并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。
		外蕴状态不可以影响享元对象的内蕴状态，它们是相互独立的。

享元模式可以分成单纯享元模式和复合享元模式两种形式：
	一、在单纯的享元模式中，所有的享元对象都是可以共享的。
		单纯享元模式所涉及到的角色如下：
		1.抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。
		2.具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。
			如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。
		3.享元工厂(FlyweightFactory)角色 ：本角色负责创建和管理享元角色。
			本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，
			享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。
			如果已经有了，享元工厂角色就应当提供这个已有的享元对象；
			如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。

	二、将一些单纯享元使用合成模式加以复合，形成复合享元对象。
		这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。
		复合享元角色所涉及到的角色如下：
　　		1.抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。
		2.具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。
			如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。
　		3.复合享元(ConcreteCompositeFlyweight)角色 ：复合享元角色所代表的对象是不可以共享的，
			但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象。
		4.享元工厂(FlyweightFactory)角色 ：本角 色负责创建和管理享元角色。
			本角色必须保证享元对象可以被系统适当地共享。
			当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有 一个符合要求的享元对象。
			如果已经有了，享元工厂角色就应当提供这个已有的享元对象；
			如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个 合适的享元对象。

享元对象能做到共享的关键是区分了内部状态和外部状态:
	内部状态：
		在享元对象内部并且不会随环境改变而改变的共享部分。
	外部状态:
		而随环境改变而改变的、不可以共享的状态.


适用性：
	1.一个应用程序使用了大量的对象。
	2.完全由于使用大量的对象，造成很大的存储开销。
	3.对象的大多数状态都可变为外部状态。
	4.如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。
	5.应用程序不依赖于对象标识。由于Flyweight 对象可以被共享，
		对于概念上明显有别的对象，标识测试将返回真值。

优缺点：
	优点：
		极大减少内存中对象的数量。
		相同或相似的对象内存只保持一份，极大的节约资源，提高系统性能。
		外部状态相对独立，不影响内部变化。
	
	缺点：
		模式较复杂，使程序逻辑复杂化。
		为了节省内存，共享了内部状态，分离出了外部状态，而读取外部状态使运行时间变长。用时间换空间。