单例模式（Singleton）：
	单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：
		1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。
		2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。
		3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。
		（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。

意图：
	保证一个类仅有一个实例，并提供一个访问它的全局访问点。

适用性：
	当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。
	当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。

场景: 
	Windows任务管理器；
	文件系统: 一个操作系统只能有一个文件系统；
	数据库连接池；
	Spring: 一个Component就只有一个实例；
	JavaWeb: 一个Servlet只有一个实例；

实现：	
	常见的单例模式实现方式有五种: 饿汉式, 懒汉式, 双重检测锁, 静态内部类, enum枚举。
	Enum是实现单例的王者，＜Effective Java＞中也推荐使用，因此Enum成为Java中实现单例的最好方式， 
	但是Enum也有其自身的限制，因此在使用时还需要做一番权衡。
	
	实现要点:
		隐藏构造器
		static Singleton实例
		暴露实例获取方法 

	追求目标：
		线程安全
		调用效率高
		延迟加载

小结
	由于单例模式只生成一个实例，减少了系统性能开销，因此 当一个对象的产生需要比较多的资源时(如读取配置/产生其他依赖对象)，
	则可以通过只产生一个单例对象，然后永久驻留内存的方式来提高系统整体性能。
	
事实上，可以通过Java反射机制来实例化private类型的构造方法，此时基本上会使所有的Java单例实现失效。
