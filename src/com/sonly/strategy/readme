策略模式(Strategy) 行为型：

意图：
	定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。
	本模式使得算法可独立于使用它的客户而变化。

适用性：
	1.许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。
	2.需要使用一个算法的不同变体。
		例如，你可能会定义一些反映不同的空间/时间权衡的算法。
		当这些变体实现为一个算法的类层次时[H087] ,可以使用策略模式。
	3.算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。
	4.一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。
		将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。
	
策略模式的角色：
	1.封装类：也叫上下文，对策略进行二次封装，目的是避免高层模块对策略的直接调用。
	2.抽象策略：通常情况下为一个接口，当各个实现类中存在着重复的逻辑时，
		则使用抽象类来封装这部分公共的代码，此时，策略模式看上去更像是模版方法模式。
	3.具体策略：具体策略角色通常由一组封装了算法的类来担任，这些类之间可以根据需要自由替换。

 优点：
	1.策略类之间可以自由切换。由于策略类实现自同一个抽象，所以他们之间可以自由切换。
	2.易于扩展。增加一个新的策略对策略模式来说非常容易，基本上可以在不改变原有代码的基础上进行扩展。
	3.避免使用多重条件，如果不使用策略模式，对于所有的算法，必须使用条件语句进行连接，
		通过条件判断来决定使用哪一种算法，使用多重条件判断是非常不容易维护的。
 缺点：
	1.维护各个策略类会给开发带来额外开销，一般来说，策略类的数量超过5个，就比较令人头疼了。
	2.必须对客户端（调用者）暴露所有的策略类，因为使用哪种策略是由客户端来决定的。
		因此，客户端应该知道有什么策略，并且了解各种策略之间的区别，否则，后果很严重。
		
案例: 
	商场打折策略可以简单分为以下三种：
	1.原价购买
	2.折扣
	3.返利