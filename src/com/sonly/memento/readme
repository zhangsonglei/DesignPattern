备忘录模式(Memento) 行为型：

意图：
	在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
	这样以后就可将该对象恢复到原先保存的状态。

适用性：
	1.必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态。
	2.如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，
	而Memento可以把复杂的对象内部信息对其他的对象屏蔽起来，从而可以恰当的保持封装的边界。
	3.事务回滚。
	4.棋类游戏中的悔棋。
	5.PhotoShop的历史记录。

角色对象组成： 
	1.发起者对象(Originator)：负责创建一个备忘录来记录当前对象的内部状态，
		并可使用备忘录恢复内部状态。 
	2.备忘录对象(Memento)：负责存储发起者对象的内部状态，并防止其他对象访问备忘录。 
	3.管理者对象(Caretaker):负责备忘录权限管理，不能对备忘录对象的内容进行访问或者操作。 

优点： 
	1、备忘录模式可以把发起人内部信息对象屏蔽起来，从而可以保持封装的边界。 
	2、简化了发起者类。当发起者角色的状态改变的时候，有可能这个状态无效，
		这时候就可以使用暂时存储起来的备忘录将状态复原。
缺点： 
	1、如果状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象比较昂贵。 
	2、当发起者对象的状态改变的时候，有可能这个协议无效。
		如果状态改变的成功率达不到要求，可以考虑采取“假如”协议模式。

序列化所有属性:
	如果Memento需要保存的是Originator的所有属性，
	那么可将Originator的所有属性都存储到一个Map<String, Object>结构中由Caretaker保存，
	这样就节省了Memento中间类的开发成本。
	甚至还可将Originator序列化为二进制流/字符串存储到持久化设备中(如磁盘、DB、Redis)，节省内存开销，

相关模式：
	命令模式: 如果在使用命令模式时需要实现命令的撤销，那么可用Memento来存储可撤销的状态。
	迭代器模式: 备忘录可用于迭代。
	
案例: 游戏进度保存
	在攻击Boss前，将当前游戏进度保存，万一失败还可从保存点重新开始。
	
