装饰模式(Decorator) 结构型：
	装饰者模式(Decorator)： 又称包装器(Wrapper)，可以动态地为一个对象添加一些额外的职责。
	 就增加功能来说， 装饰者模式是一种用于替代继承的技术，他无须通过增加子类继承就能扩展对象的已有功能，
	 而是使用对象的关联关系代替继承关系 ，更加灵活，同时还可避免类型体系的快速膨胀。

在装饰模式中的角色有：
	1.抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。
	2.具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。
	3.装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。
	4.具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。

适用性：
	1.在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
	2.处理那些可以撤消的职责。
	3.当不能采用生成子类的方法进行扩充时。
		一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，
		使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。

与桥接模式的对比 ：
	两个模式都是为了解决子类过多问题, 但他们的诱因不同: 
		桥接模式对象自身有沿着多个维度变化的趋势, 本身不稳定;
		装饰者模式对象自身非常稳定, 只是为了增加新功能/增强原功能.

与适配器模式的不同：
	装饰者与适配器都有一个别名:包装模式(Wrapper), 它们看似都是起到包装一个接口/类/对象的作用,
		 但包装形式却不同.
	适配器的意义是将一个接口转变成另一个接口: 通过改变接口达到重复使用的目的;
	而装饰者不改变被装饰对象的接口, 而恰恰保持了原有的接口: 
		增强原有对象的功能, 或改变原有对象的处理方法而提升性能.

继承、装饰者模式、动态代理对比:
	*	继承			装饰者		动态代理
	对象	被增强对象不能变	被增强对象可变	被增强对象可变
	内容	增强内容不能变	增强内容不可变	增强内容可变


装饰模式的优点:
	1.装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。
		装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。
		继承关系则不同，继承关系是静态的，它在系统运行前就决定了。
	2.通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。

装饰模式的缺点:
　　	由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。
	但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。
	更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。

例子：
	现在需要一个汉堡，主体是鸡腿堡，可以选择添加生菜、酱、辣椒等等许多其他的配料。